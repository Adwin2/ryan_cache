# 第四章：一致性哈希

> 🎯 **学习目标**: 掌握分布式缓存的核心算法 - 一致性哈希
> 
> ⚠️ **面试重点**: 这是分布式系统面试的必考算法！

## 📖 理论知识

### 为什么需要一致性哈希？

在分布式缓存系统中，我们需要将数据分布到多个缓存节点上。传统的哈希方法存在严重问题：

#### 传统哈希的问题

```go
// 传统哈希分布
nodeIndex = hash(key) % nodeCount

// 问题：当节点数量变化时，大量数据需要重新分布
// 例如：3个节点 → 4个节点，约75%的数据需要迁移！
```

#### 一致性哈希的优势

```
1. 节点增减时，只影响相邻节点的数据
2. 数据迁移量最小化
3. 负载分布相对均匀
4. 扩展性好
```

### 一致性哈希原理

#### 1. 哈希环 (Hash Ring)

将哈希值空间组织成一个环形结构：

```
        0
    ┌───────┐
  3 │       │ 1
    │   ○   │
  2 │       │ 
    └───────┘
```

#### 2. 节点映射

将缓存节点映射到哈希环上：

```
        Node A (hash=1)
    ┌───────┐
Node D│       │ 
(hash=3)  ○   │ Node B (hash=2)
    │       │ 
    └───────┘
        Node C (hash=2.5)
```

#### 3. 数据定位

数据按顺时针方向找到第一个节点：

```
Key1 (hash=0.5) → Node A
Key2 (hash=1.5) → Node B  
Key3 (hash=2.2) → Node C
Key4 (hash=3.5) → Node D
```

#### 4. 虚拟节点

为了解决数据倾斜问题，引入虚拟节点：

```
每个物理节点对应多个虚拟节点
Node A → VNode A1, VNode A2, VNode A3...
Node B → VNode B1, VNode B2, VNode B3...
```

## 🔍 算法详解

### 核心操作

1. **AddNode(node)**: 添加节点到哈希环
2. **RemoveNode(node)**: 从哈希环移除节点
3. **GetNode(key)**: 根据key找到对应的节点
4. **GetNodes(key, count)**: 获取多个副本节点

### 时间复杂度

- **查找节点**: O(log N) - 使用二分查找
- **添加节点**: O(log N) 
- **删除节点**: O(log N)

## 💻 代码实现

查看具体实现：
- `hash_ring.go` - 基础哈希环实现
- `virtual_nodes.go` - 虚拟节点优化
- `demo.go` - 完整演示程序

## 🎮 动手实践

```bash
cd 04-consistent-hash
go run *.go
```

## 📝 面试要点

### 必考问题

**Q: 什么是一致性哈希？为什么需要它？**

A: 一致性哈希是一种特殊的哈希算法，用于解决分布式系统中数据分布问题。
- **传统哈希问题**: 节点变化时大量数据需要重新分布
- **一致性哈希优势**: 节点变化时只影响相邻节点，最小化数据迁移

**Q: 一致性哈希的基本原理是什么？**

A: 
1. **哈希环**: 将哈希空间组织成环形结构
2. **节点映射**: 将服务器节点映射到环上
3. **数据定位**: 数据顺时针找到第一个节点
4. **虚拟节点**: 解决数据倾斜问题

**Q: 虚拟节点的作用是什么？**

A:
- **问题**: 物理节点较少时，数据分布不均匀
- **解决**: 每个物理节点对应多个虚拟节点
- **效果**: 提高数据分布的均匀性

### 进阶问题

**Q: 一致性哈希如何处理节点故障？**

A:
1. **故障检测**: 监控节点健康状态
2. **自动移除**: 将故障节点从哈希环移除
3. **数据迁移**: 故障节点的数据迁移到下一个节点
4. **副本机制**: 使用多副本提高可用性

**Q: 一致性哈希的缺点有哪些？**

A:
1. **数据倾斜**: 节点较少时分布不均
2. **雪崩效应**: 节点故障可能引发连锁反应
3. **复杂性**: 实现比传统哈希复杂
4. **副本一致性**: 多副本间的数据一致性问题

## 🏭 实际应用

### 知名系统的使用

- **Amazon DynamoDB**: 数据分片
- **Apache Cassandra**: 数据分布
- **Redis Cluster**: 槽位分配
- **Memcached**: 客户端分片

### 应用场景

1. **分布式缓存**: Redis/Memcached集群
2. **分布式存储**: 数据分片和副本
3. **负载均衡**: 请求分发
4. **CDN**: 内容分发网络

## 🔧 优化策略

### 1. 虚拟节点数量

```go
// 经验值：每个物理节点150-200个虚拟节点
virtualNodeCount := 150
```

### 2. 哈希函数选择

```go
// 推荐使用：
// - MD5: 速度快，分布均匀
// - SHA1: 安全性更好
// - FNV: 非加密哈希，性能最好
```

### 3. 负载均衡

```go
// 加权一致性哈希
// 根据节点性能分配不同权重
nodeWeight := map[string]int{
    "node1": 100,  // 高性能节点
    "node2": 50,   // 低性能节点
}
```

## 📊 性能分析

### 数据迁移量对比

| 场景 | 传统哈希 | 一致性哈希 |
|------|----------|------------|
| 3→4节点 | 75% | 25% |
| 4→5节点 | 80% | 20% |
| 10→11节点 | 90.9% | 9.1% |

### 查找性能

- **时间复杂度**: O(log N)
- **空间复杂度**: O(N × V) (V为虚拟节点数)
- **实际性能**: 微秒级查找

## 🔗 下一章预告

下一章我们将学习**多级缓存**：
- 本地缓存 + 分布式缓存架构
- 缓存层级设计
- 数据一致性保证
- 性能优化策略

多级缓存是现代高性能系统的标配！

---

**继续学习**: [第五章：多级缓存](../05-multilevel/)
