# 第一章：缓存基础

> 🎯 **学习目标**: 理解缓存的基本概念，掌握简单缓存的实现原理

## 📖 理论知识

### 什么是缓存？

缓存（Cache）是一种存储技术，将**频繁访问的数据**存储在**访问速度更快的存储介质**中，以提高数据访问效率。

```
用户请求 → 缓存 → 数据库
         ↑ 快    ↑ 慢
```

### 为什么需要缓存？

1. **提升性能**: 内存访问比磁盘快1000倍以上
2. **减少负载**: 减轻数据库压力
3. **降低延迟**: 就近访问，减少网络开销
4. **提高并发**: 缓存可以处理更多并发请求

### 缓存的基本原理

**局部性原理**：
- **时间局部性**: 刚被访问的数据很可能再次被访问
- **空间局部性**: 相邻的数据很可能被一起访问

### 缓存的层次结构

```
CPU缓存 (L1/L2/L3) → 内存 → SSD → 机械硬盘 → 网络存储
    快 ←————————————————————————————————————————→ 慢
   小容量 ←——————————————————————————————————→ 大容量
```

## 💻 代码实现

### 1. 最简单的缓存实现

查看 `simple_cache.go` - 一个基于map的内存缓存：

```go
type SimpleCache struct {
    data map[string]interface{}
    mu   sync.RWMutex
}
```

**核心操作**：
- `Get(key)` - 获取数据
- `Set(key, value)` - 存储数据  
- `Delete(key)` - 删除数据

### 2. 带过期时间的缓存

查看 `simple_cache.go` 中的 `CacheWithTTL` 实现：

```go
type CacheItem struct {
    Value     interface{}
    ExpiresAt time.Time
}
```

**新增功能**：
- TTL (Time To Live) 支持
- 自动过期清理
- 过期检查

## 🎮 动手实践

运行演示程序：

```bash
cd 01-basics
go run demo.go
```

**演示内容**：
1. 基本的GET/SET操作
2. 缓存命中 vs 缓存未命中
3. TTL过期演示
4. 性能对比（缓存 vs 直接数据库查询）

## 🤔 思考题

1. 为什么使用 `sync.RWMutex` 而不是 `sync.Mutex`？
2. 如果缓存满了怎么办？
3. 如何处理缓存和数据库的数据一致性？

## 📝 面试要点

### 基础问题

**Q: 什么是缓存？为什么要使用缓存？**

A: 缓存是将频繁访问的数据存储在高速存储介质中的技术。使用缓存的原因：
- 提升访问速度（内存比磁盘快1000倍）
- 减少数据库负载
- 降低网络延迟
- 提高系统并发能力

**Q: 缓存和数据库有什么区别？**

A: 
| 维度 | 缓存 | 数据库 |
|------|------|--------|
| 速度 | 快 | 相对慢 |
| 容量 | 小 | 大 |
| 持久性 | 易失 | 持久 |
| 一致性 | 弱 | 强 |
| 成本 | 高 | 低 |

**Q: 什么是缓存命中率？如何提高？**

A: 缓存命中率 = 缓存命中次数 / 总请求次数
提高方法：
- 合理设置缓存大小
- 选择合适的淘汰策略
- 预热热点数据
- 优化缓存键设计

### 进阶问题

**Q: 如何设计一个线程安全的缓存？**

A: 
1. 使用读写锁 (`sync.RWMutex`)
2. 读操作用读锁，写操作用写锁
3. 考虑锁的粒度，避免锁竞争
4. 可以考虑分段锁提高并发性

**Q: 缓存的过期策略有哪些？**

A:
1. **定时过期**: 设置固定过期时间
2. **惰性过期**: 访问时检查是否过期
3. **定期过期**: 后台定时清理过期数据
4. **LRU**: 最近最少使用淘汰
5. **LFU**: 最少使用频率淘汰

## 🔗 下一章预告

下一章我们将学习**缓存模式**，了解应用程序如何与缓存交互：
- Cache-Aside（旁路缓存）
- Write-Through（写穿透）
- Write-Back（写回）

这些模式在面试中经常被问到，是必须掌握的知识点！

---

**继续学习**: [第二章：缓存模式](../02-patterns/)
