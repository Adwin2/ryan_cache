# 第二章：缓存模式

> 🎯 **学习目标**: 掌握三种主要缓存模式的原理、实现和应用场景
> 
> ⚠️ **面试重点**: 这是面试中的高频考点，必须熟练掌握！

## 📖 理论知识

### 为什么需要缓存模式？

在实际应用中，缓存不是孤立存在的，它需要与数据库协同工作。不同的协同方式就形成了不同的缓存模式。

### 三种主要缓存模式

```
1. Cache-Aside (旁路缓存)    - 应用程序管理缓存
2. Write-Through (写穿透)    - 写入时同步更新缓存和数据库  
3. Write-Back (写回)        - 延迟写入数据库
```

## 🔍 模式详解

### 1. Cache-Aside (旁路缓存) ⭐⭐⭐⭐⭐

**最常用的模式**，应用程序直接管理缓存。

#### 读流程：
```
1. 应用程序查询缓存
2. 如果缓存命中 → 返回数据
3. 如果缓存未命中 → 查询数据库 → 写入缓存 → 返回数据
```

#### 写流程：
```
1. 应用程序更新数据库
2. 应用程序删除缓存 (或更新缓存)
```

#### 优点：
- ✅ 简单易理解
- ✅ 应用程序完全控制
- ✅ 缓存故障不影响数据库

#### 缺点：
- ❌ 需要应用程序管理缓存逻辑
- ❌ 可能出现数据不一致

### 2. Write-Through (写穿透) ⭐⭐⭐⭐

写入时同时更新缓存和数据库。

#### 读流程：
```
1. 应用程序查询缓存
2. 如果缓存命中 → 返回数据
3. 如果缓存未命中 → 查询数据库 → 写入缓存 → 返回数据
```

#### 写流程：
```
1. 应用程序写入缓存
2. 缓存同步写入数据库
3. 两者都成功才返回成功
```

#### 优点：
- ✅ 数据一致性好
- ✅ 缓存总是最新的

#### 缺点：
- ❌ 写入延迟高（需要同时写两个地方）
- ❌ 缓存故障影响写入

### 3. Write-Back (写回) ⭐⭐⭐

延迟写入数据库，先写缓存。

#### 读流程：
```
1. 应用程序查询缓存
2. 如果缓存命中 → 返回数据
3. 如果缓存未命中 → 查询数据库 → 写入缓存 → 返回数据
```

#### 写流程：
```
1. 应用程序写入缓存
2. 标记为"脏数据"
3. 异步批量写入数据库
```

#### 优点：
- ✅ 写入性能最好
- ✅ 可以批量写入数据库

#### 缺点：
- ❌ 数据可能丢失（缓存故障）
- ❌ 实现复杂

## 📊 模式对比

| 特性 | Cache-Aside | Write-Through | Write-Back |
|------|-------------|---------------|------------|
| **实现复杂度** | 简单 | 中等 | 复杂 |
| **读性能** | 好 | 好 | 好 |
| **写性能** | 好 | 一般 | 最好 |
| **数据一致性** | 弱 | 强 | 最弱 |
| **数据安全性** | 好 | 好 | 风险 |
| **适用场景** | 通用 | 强一致性要求 | 高写入场景 |

## 💻 代码实现

查看具体实现：
- `cache_aside.go` - Cache-Aside模式实现
- `write_through.go` - Write-Through模式实现  
- `write_back.go` - Write-Back模式实现
- `comparison_demo.go` - 三种模式对比演示

## 🎮 动手实践

```bash
cd 02-patterns
go run comparison_demo.go
```

## 📝 面试要点

### 必考问题

**Q: 请解释Cache-Aside、Write-Through、Write-Back三种缓存模式的区别？**

A: 
- **Cache-Aside**: 应用程序管理缓存，读时查缓存+数据库，写时更新数据库+删除缓存
- **Write-Through**: 写入时同步更新缓存和数据库，保证一致性但性能较差
- **Write-Back**: 先写缓存后异步写数据库，性能最好但有数据丢失风险

**Q: Cache-Aside模式中，为什么写入时要删除缓存而不是更新缓存？**

A: 
1. **避免并发问题**: 更新缓存可能导致数据不一致
2. **减少无效写入**: 删除的数据可能不会被立即读取
3. **简化逻辑**: 删除比更新更简单可靠

**Q: 什么场景下选择Write-Back模式？**

A:
- 写入频繁的场景（如日志、计数器）
- 对写入性能要求极高
- 可以容忍少量数据丢失
- 有可靠的持久化机制

### 进阶问题

**Q: Cache-Aside模式如何解决数据一致性问题？**

A:
1. **延迟双删**: 删除缓存 → 更新数据库 → 延迟删除缓存
2. **消息队列**: 通过MQ异步删除缓存
3. **版本号**: 使用版本号检测数据变化
4. **TTL**: 设置较短的过期时间

**Q: Write-Through和Write-Back的性能差异有多大？**

A: 
- **Write-Through**: 写入延迟 = 缓存延迟 + 数据库延迟
- **Write-Back**: 写入延迟 ≈ 缓存延迟
- 性能差异可达10-100倍，取决于数据库性能

## 🔗 实际应用

### 各大公司的选择

- **Redis**: 主要支持Cache-Aside
- **Memcached**: Cache-Aside模式
- **CPU缓存**: Write-Back模式
- **数据库缓冲池**: Write-Back模式

### 最佳实践

1. **大多数场景**: 使用Cache-Aside
2. **强一致性**: 使用Write-Through
3. **高性能写入**: 使用Write-Back
4. **混合使用**: 读用Cache-Aside，写用Write-Through

## 🔗 下一章预告

下一章我们将学习**缓存问题**：
- 缓存雪崩 (Cache Avalanche)
- 缓存穿透 (Cache Penetration)  
- 缓存击穿 (Cache Breakdown)

这些是生产环境中的常见问题，也是面试的重点！

---

**继续学习**: [第三章：缓存问题](../03-problems/)
